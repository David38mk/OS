#!/bin/bash

if [ "$#" -lt 1  ]; then
	datoteka1=$(find . -type f -name "naredbi.txt" | head -1)
	cp "$datoteka1" ./"naredbi.txt"
	datoteka1="naredbi.txt"
else
	datoteka1="$1"
fi
actions=$(find . -type f -name "actions.txt")
if [ -n "$actions" ]; then
	for command in $(./python_scripta "$datoteka1" "$actions"); do
		eval "$command"
	done
else
	echo "Ne ja pronajdovme actions.txt"
	exit 1
fi

# Да се напише SHELL скрипта која како аргумент од командна линија добива име на влезна датотека.
# Доколку не се прати аргумент на командна линија, тогаш се пребарува датотека со име „naredbi.txt“ во
# тековниот директориум и неговите поддиректориуми и доколку се најде, тогаш се копира таа датотека
# во тековниот директориум (доколку истата не е во тековниот директориум). Потоа, скриптата пребарува
# во тековниот директориум и неговите поддиректориуми датотека со име „аctions.txt“. Доколку најде, ја
# повикува Python скриптата од првата задача, каде како прв аргумент се праќа датотеката „naredbi.txt“, а
# како втор аргумент се праќа датотеката „actions.txt“, притоа втората датотека се праќа со апсолутната
# патека каде ќе биде пронајдена. Секоја една наредба што ќе се врати од извршувањето на PERL
# скриптата се извршува од страна на SHELL скриптата. Доколку наредбата врати некаков текст од
# извршувањето, тогаш се печати името на наредбата и грешка во продолжение. Доколку не врати текст,
# тогаш се печати името на наредбата и текстот „ОК“ во продолжение.


